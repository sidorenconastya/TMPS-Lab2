# Паттерн "Фасад" (car_class package)
Данный паттерн позволяет скрыть сложность логики системы путем сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

В данном примере в качестве этого самого фасада выступает класс CarClass, в котором присутвуют функции создания машин различных классов. Также в данном процессе присутствует взаимодействие таких паттернов как Фасад, Мост и Декоратор.

```sh
public Crossover carPremiumClass() {
		return new Crossover(new PanoramicWindow(new CruiseControl(new Car())));
}
```
# Паттерн "Мост" (сar_body package)
Мост используется в тех случаях, когда необходимо разделить абстракцию и реализацию, чтобы они могли изменяться независимо друг от друга.

Рассматривая текущий пример на основе различных типов машин, было принято решение использовать шаблон Мост для разделения на два уровня тип кузова машины и различные комплектации.

```sh
abstract class CarBody {
	public CarBody() {}
	
	public CarBody(CarComponent carType){
		String carBodyType = null;
		String name = carBodyType + carType.name;
	}
}
```
# Паттерн "Декоратор" (car package)
Декоратор является еще одним пример структурных шаблонов программирования, который предназначен для динамического подключения дополнительного поведения к объекту. Таким образом, данный шаблон представляет альтернаттиву созданию подклассов с целью расширения функционала.

В данном примере с помощью декоратора были созданы так называемые "обертки" для дальнейшего создания различных машин. 

Можно рассмотреть пример класса одной из таких "оберток", которая реализует интерфейс CarComponent. 
```sh
public class CruiseControl implements CarComponent{
	public CruiseControl(CarComponent base) {
		String name = base.name + "with Cruise-Control";
	}
}
```
# Паттерн "Команда" (car_credit package)
Цель данного шаблона - создание структуры, в которой класс-отправитель и класс-получатель не зависят друг от друга напрямую. Объект команды заключает в себе само дейтсвие и его параметры.

В рассматриваемом примере был создан интерфейс с методом buyViaCredit(), реализация которого менятеся в зависимости от класса , имплеметирующего данный интерфейс. То есть в качестве команд выступает покупка машины в кредит и этом случае не важно, какой именно тип машины покупается в кредит.

```sh
@Override
	public CarBody buyViaCredit() {
		CarClass carClass = new CarClass();
		return carClass.carMediumClass();
	}
```
Стоит отметить, что здесь также используется ранее написанная функция в контексте применения шаблона Фасад.
