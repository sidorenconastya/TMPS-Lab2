# Паттерн "Фасад" (car_class package)
Данный паттерн позволяет скрыть сложность логики системы путем сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

В данном примере в качестве этого самого фасада выступает класс CarClass, в котором присутвуют функции создания машин различных классов. Также в данном процессе присутствует взаимодействие таких паттернов как Фасад, Мост и Декоратор.

```sh
public Crossover carPremiumClass() {
		return new Crossover(new PanoramicWindow(new CruiseControl(new Car())));
}
```
# Паттерн "Мост" (сar_body package)
Мост используется в тех случаях, когда необходимо разделить абстракцию и реализацию, чтобы они могли изменяться независимо друг от друга.

Рассматривая текущий пример на основе различных типов машин, было принято решение использовать шаблон Мост для разделения на два уровня тип кузова машины и различные комплектации.

```sh
abstract class CarBody {
	public CarBody() {}
	
	public CarBody(CarComponent carType){
		String carBodyType = null;
		String name = carBodyType + carType.name;
	}
}
```
# Паттерн "Декоратор" (car package)
Декоратор является еще одним пример структурных шаблонов программирования, который предназначен для динамического подключения дополнительного поведения к объекту. Таким образом, данный шаблон представляет альтернаттиву созданию подклассов с целью расширения функционала.

В данном примере с помощью декоратора были созданы так называемые "обертки" для дальнейшего создания различных машин. 

Можно рассмотреть пример класса одной из таких "оберток", которая реализует интерфейс CarComponent. 
```sh
public class CruiseControl implements CarComponent{
	public CruiseControl(CarComponent base) {
		String name = base.name + "with Cruise-Control";
	}
}
```
